<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Estimating ancestry · MendelImpute</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MendelImpute</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../Phasing_and_Imputation/">Phasing and Imputation</a></li><li><a class="tocitem" href="../performance/">Performance Gotchas</a></li><li class="is-active"><a class="tocitem" href>Estimating ancestry</a><ul class="internal"><li><a class="tocitem" href="#Prepare-Example-data-for-illustration"><span>Prepare Example data for illustration</span></a></li><li><a class="tocitem" href="#Global-ancestry-inference"><span>Global ancestry inference</span></a></li><li><a class="tocitem" href="#Local-ancestry-inference"><span>Local ancestry inference</span></a></li></ul></li><li><a class="tocitem" href="../ultra+compress/">Ultra compression</a></li><li><a class="tocitem" href="../script/">Run as script</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Estimating ancestry</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Estimating ancestry</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/OpenMendel/MendelImpute.jl/blob/master/docs/src/man/painting.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Estimating-ancestry"><a class="docs-heading-anchor" href="#Estimating-ancestry">Estimating ancestry</a><a id="Estimating-ancestry-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-ancestry" title="Permalink"></a></h1><p>If samples in the reference haplotype panel are labeled with a population origin, MendelImpute can also be used for:</p><ul><li>Local ancestry inference (chromosome painting)</li><li>Global ancestry inference </li></ul><pre><code class="language-julia hljs"># first load all necessary packages
using MendelImpute
using StatsPlots</code></pre><h2 id="Prepare-Example-data-for-illustration"><a class="docs-heading-anchor" href="#Prepare-Example-data-for-illustration">Prepare Example data for illustration</a><a id="Prepare-Example-data-for-illustration-1"></a><a class="docs-heading-anchor-permalink" href="#Prepare-Example-data-for-illustration" title="Permalink"></a></h2><p>We use the <a href="http://bochet.gcc.biostat.washington.edu/beagle/1000_Genomes_phase3_v5a/b37.vcf/">1000 genomes chromosome 22</a> as illustration.  The original data is filtered into target and reference panels. Follow <a href="https://openmendel.github.io/MendelImpute.jl/dev/man/Phasing_and_Imputation/#Detailed-Example">detailed example</a> in Phasing and Imputation to obtain the same data.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In practice, it is better to infer ancestry of admixed populations using non-admixed reference populations. The example here is a simplified illustration and should not be taken too literally. </p></div></div><h3 id="Process-each-sample&#39;s-population-origin"><a class="docs-heading-anchor" href="#Process-each-sample&#39;s-population-origin">Process each sample&#39;s population origin</a><a id="Process-each-sample&#39;s-population-origin-1"></a><a class="docs-heading-anchor-permalink" href="#Process-each-sample&#39;s-population-origin" title="Permalink"></a></h3><p>MendelImpute needs to know each reference sample&#39;s origin (country/ethnicity/region...etc). This origin information should be provided by the reference haplotype panel, but users are free to further organize origin labels base on their own criteria. For this purpose, <code>MendelImpute</code> needs a <code>Dict{key, value}</code> where each key is a reference sample ID and the value is the population code. Example dictionaries for 1000 genome project can be created by <code>MendelImpute</code>&#39;s internal helper functions. Users not using 1000 genomes would have to manually construct such a dictionary mapping reference sample IDs to a desired population label. </p><p>Here is a dictionary mapping sample IDs (from 1000 genomes project) to their super <a href="https://www.internationalgenome.org/category/population/">population codes</a>.</p><pre><code class="language-julia hljs">refID_to_superpopulation = thousand_genome_samples_to_super_population()</code></pre><pre><code class="nohighlight hljs">Dict{String, String} with 2504 entries:
  &quot;HG01791&quot; =&gt; &quot;EUR&quot;
  &quot;HG02736&quot; =&gt; &quot;SAS&quot;
  &quot;HG00182&quot; =&gt; &quot;EUR&quot;
  &quot;HG03914&quot; =&gt; &quot;SAS&quot;
  &quot;HG00149&quot; =&gt; &quot;EUR&quot;
  &quot;NA12156&quot; =&gt; &quot;EUR&quot;
  &quot;HG02642&quot; =&gt; &quot;AFR&quot;
  &quot;HG02851&quot; =&gt; &quot;AFR&quot;
  &quot;NA19835&quot; =&gt; &quot;AFR&quot;
  &quot;NA19019&quot; =&gt; &quot;AFR&quot;
  &quot;HG01131&quot; =&gt; &quot;AMR&quot;
  &quot;HG03578&quot; =&gt; &quot;AFR&quot;
  &quot;NA18550&quot; =&gt; &quot;EAS&quot;
  &quot;HG02401&quot; =&gt; &quot;EAS&quot;
  &quot;HG01350&quot; =&gt; &quot;AMR&quot;
  &quot;HG03973&quot; =&gt; &quot;SAS&quot;
  &quot;NA07000&quot; =&gt; &quot;EUR&quot;
  &quot;HG01709&quot; =&gt; &quot;EUR&quot;
  &quot;HG01395&quot; =&gt; &quot;AMR&quot;
  &quot;HG01980&quot; =&gt; &quot;AMR&quot;
  &quot;HG01979&quot; =&gt; &quot;AMR&quot;
  &quot;HG01122&quot; =&gt; &quot;AMR&quot;
  &quot;HG03869&quot; =&gt; &quot;SAS&quot;
  &quot;HG03729&quot; =&gt; &quot;SAS&quot;
  &quot;NA19920&quot; =&gt; &quot;AFR&quot;
  ⋮         =&gt; ⋮</code></pre><p>Here is another dictionary mapping population code to super population codes. Thus we can map samples to super populations.</p><pre><code class="language-julia hljs">pop_to_superpop = thousand_genome_population_to_superpopulation()</code></pre><pre><code class="nohighlight hljs">Dict{String, String} with 26 entries:
  &quot;CHS&quot; =&gt; &quot;EAS&quot;
  &quot;CDX&quot; =&gt; &quot;EAS&quot;
  &quot;GIH&quot; =&gt; &quot;SAS&quot;
  &quot;MSL&quot; =&gt; &quot;AFR&quot;
  &quot;KHV&quot; =&gt; &quot;EAS&quot;
  &quot;PUR&quot; =&gt; &quot;AMR&quot;
  &quot;ACB&quot; =&gt; &quot;AFR&quot;
  &quot;CLM&quot; =&gt; &quot;AMR&quot;
  &quot;FIN&quot; =&gt; &quot;EUR&quot;
  &quot;TSI&quot; =&gt; &quot;EUR&quot;
  &quot;BEB&quot; =&gt; &quot;SAS&quot;
  &quot;LWK&quot; =&gt; &quot;AFR&quot;
  &quot;STU&quot; =&gt; &quot;SAS&quot;
  &quot;JPT&quot; =&gt; &quot;EAS&quot;
  &quot;PJL&quot; =&gt; &quot;SAS&quot;
  &quot;ITU&quot; =&gt; &quot;SAS&quot;
  &quot;MXL&quot; =&gt; &quot;AMR&quot;
  &quot;GWD&quot; =&gt; &quot;AFR&quot;
  &quot;CEU&quot; =&gt; &quot;EUR&quot;
  &quot;YRI&quot; =&gt; &quot;AFR&quot;
  &quot;ASW&quot; =&gt; &quot;AFR&quot;
  &quot;ESN&quot; =&gt; &quot;AFR&quot;
  &quot;CHB&quot; =&gt; &quot;EAS&quot;
  &quot;IBS&quot; =&gt; &quot;EUR&quot;
  &quot;PEL&quot; =&gt; &quot;AMR&quot;
  &quot;GBR&quot; =&gt; &quot;EUR&quot;</code></pre><h2 id="Global-ancestry-inference"><a class="docs-heading-anchor" href="#Global-ancestry-inference">Global ancestry inference</a><a id="Global-ancestry-inference-1"></a><a class="docs-heading-anchor-permalink" href="#Global-ancestry-inference" title="Permalink"></a></h2><p>Running global ancestry inference will produce a matrix <code>Q</code> where row <code>i</code> is the ancestry proportion of sample <code>i</code>. </p><pre><code class="language-julia hljs">tgtfile = &quot;target.chr22.typedOnly.masked.vcf.gz&quot;
reffile = &quot;ref.chr22.maxd1000.excludeTarget.jlso&quot;
superpopulations = unique(values(pop_to_superpop))
Q = admixture_global(tgtfile, reffile, refID_to_superpopulation, superpopulations);</code></pre><pre><code class="nohighlight hljs">Number of threads = 1
Importing reference haplotype data...


[32mComputing optimal haplotypes...100%|████████████████████| Time: 0:00:28[39m
[32mPhasing...100%|█████████████████████████████████████████| Time: 0:00:05[39m


Total windows = 1634, averaging ~ 508 unique haplotypes per window.

Timings: 
    Data import                     = 13.4081 seconds
        import target data             = 4.22697 seconds
        import compressed haplotypes   = 9.18115 seconds
    Computing haplotype pair        = 28.9244 seconds
        BLAS3 mul! to get M and N      = 1.17107 seconds per thread
        haplopair search               = 22.3658 seconds per thread
        initializing missing           = 0.123895 seconds per thread
        allocating and viewing         = 0.225084 seconds per thread
        index conversion               = 0.00800339 seconds per thread
    Phasing by win-win intersection = 5.15749 seconds
        Window-by-window intersection  = 0.577337 seconds per thread
        Breakpoint search              = 3.25451 seconds per thread
        Recording result               = 0.188439 seconds per thread
    Imputation                     = 3.9812 seconds
        Imputing missing               = 0.0254229 seconds
        Writing to file                = 3.95578 seconds

    Total time                      = 51.6225 seconds</code></pre><p>Each row of <code>Q</code> equals the sample&#39;s estimated ancestry (in %) from <code>superpopulations[i]</code>. For instance, sample 1 is 6% East Asian, 8% South Asian, 2% African, 16% American, and 65% European...etc.</p><pre><code class="language-julia hljs">@show Q[1:10, :]; # sample 1~10 composition</code></pre><pre><code class="nohighlight hljs">Q[1:10, :] = 10×5 DataFrame
│ Row │ EAS       │ SAS       │ AFR        │ AMR       │ EUR      │
│     │ Float64   │ Float64   │ Float64    │ Float64   │ Float64  │
├─────┼───────────┼───────────┼────────────┼───────────┼──────────┤
│ 1   │ 0.0681544 │ 0.0885727 │ 0.0226148  │ 0.16854   │ 0.652118 │
│ 2   │ 0.073303  │ 0.0818105 │ 0.0164129  │ 0.0898631 │ 0.738611 │
│ 3   │ 0.63185   │ 0.0973974 │ 0.00959202 │ 0.0729546 │ 0.188206 │
│ 4   │ 0.687351  │ 0.0608572 │ 0.0101534  │ 0.0530236 │ 0.188614 │
│ 5   │ 0.65251   │ 0.0811557 │ 0.010734   │ 0.0779404 │ 0.17766  │
│ 6   │ 0.671986  │ 0.0712596 │ 0.00997388 │ 0.0715984 │ 0.175182 │
│ 7   │ 0.103472  │ 0.0649164 │ 0.0136704  │ 0.425958  │ 0.391982 │
│ 8   │ 0.0764429 │ 0.0729965 │ 0.0628898  │ 0.323463  │ 0.464208 │
│ 9   │ 0.06995   │ 0.0772293 │ 0.0428307  │ 0.342301  │ 0.467689 │
│ 10  │ 0.0644077 │ 0.0909931 │ 0.0358219  │ 0.293383  │ 0.515394 │</code></pre><p>We can visualize all samples&#39;s global admixture with a plot you might have seen elsewhere:</p><pre><code class="language-julia hljs">global_plt = groupedbar(Matrix(Q), linecolor=nothing, bar_position = :stack,
    label=[&quot;EUR&quot; &quot;SAS&quot; &quot;AFR&quot; &quot;AMR&quot; &quot;EAS&quot;], legend=:outerright, size=(1000, 150), dpi=300)

savefig(global_plt, &quot;global_admixture.png&quot;)
display(&quot;image/png&quot;, read(&quot;global_admixture.png&quot;))</code></pre><p><img src="../output_11_0.png" alt="png"/></p><h2 id="Local-ancestry-inference"><a class="docs-heading-anchor" href="#Local-ancestry-inference">Local ancestry inference</a><a id="Local-ancestry-inference-1"></a><a class="docs-heading-anchor-permalink" href="#Local-ancestry-inference" title="Permalink"></a></h2><p>Now we turn to local ancestry inference, or chromosome painting. We still need to process each sample&#39;s population origin as detailed in the top of this page. The only difference is now you must additionally supply a color gradient for different populations manually. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The plotting code here depends on StatsPlots.jl at version v0.14.17. If plotting doesn&#39;t work, try <code>using Pkg;Pkg.pin(name=&quot;StatsPlots&quot;, version=&quot;0.14.17&quot;)</code>.</p></div></div><pre><code class="language-julia hljs"># We pick our colors here: https://mdigi.tools/color-shades/#008000.
continent = [&quot;SAS&quot;, &quot;EAS&quot;, &quot;EUR&quot;, &quot;AMR&quot;, &quot;AFR&quot;]
continent_colors = [colorant&quot;#e6194B&quot;, colorant&quot;#800000&quot;, colorant&quot;#4363d8&quot;, colorant&quot;#0000b3&quot;, colorant&quot;#bfef45&quot;]

# run MendelImpute to get local ancestries
tgtfile = &quot;target.chr22.typedOnly.masked.vcf.gz&quot;
reffile = &quot;ref.chr22.maxd1000.excludeTarget.jlso&quot;
Q, pop_colors = admixture_local(tgtfile, reffile, refID_to_superpopulation, 
    continent, continent_colors);</code></pre><pre><code class="nohighlight hljs">Number of threads = 1
Importing reference haplotype data...


[32mComputing optimal haplotypes...100%|████████████████████| Time: 0:00:24[39m
[32mPhasing...100%|█████████████████████████████████████████| Time: 0:00:05[39m


Total windows = 1634, averaging ~ 508 unique haplotypes per window.

Timings: 
    Data import                     = 8.32839 seconds
        import target data             = 1.71787 seconds
        import compressed haplotypes   = 6.61052 seconds
    Computing haplotype pair        = 24.912 seconds
        BLAS3 mul! to get M and N      = 1.27734 seconds per thread
        haplopair search               = 23.2227 seconds per thread
        initializing missing           = 0.136352 seconds per thread
        allocating and viewing         = 0.238768 seconds per thread
        index conversion               = 0.0202952 seconds per thread
    Phasing by win-win intersection = 5.7508 seconds
        Window-by-window intersection  = 0.88523 seconds per thread
        Breakpoint search              = 4.53825 seconds per thread
        Recording result               = 0.299743 seconds per thread
    Imputation                     = 0.172601 seconds
        Imputing missing               = 0.00086028 seconds
        Writing to file                = 0.171741 seconds

    Total time                      = 39.1647 seconds</code></pre><p>Lets plot the local ancestries of</p><ul><li>Samples 1 (British)</li><li>Sample 4 (Chinese)</li><li>Sample 84 (Kenyan)</li></ul><p>Their haplotypes occupy rows 1-2, 7-8, and 167-168 of <code>Q</code>, and their haplotype colors are stored in corresponding rows of <code>pop_colors</code>. </p><pre><code class="language-julia hljs"># sample index and axis labels
sample_idx = [1, 2, 7, 8, 167, 168]
sample_Q = Q[sample_idx, :]
sample_color = pop_colors[sample_idx, :]

# make plot
xnames = [&quot;Sample 1 hap1&quot;, &quot;Sample 1 hap2&quot;, &quot;Sample 4 hap1&quot;, &quot;Sample 4 hap2&quot;, &quot;Sample 84 hap1&quot;, &quot;Sample 84 hap2&quot;]
ynames = [&quot;SNP 1&quot;, &quot;SNP 208k&quot;, &quot;SNP 417k&quot;]
local_plt = groupedbar(sample_Q, bar_position = :stack, bar_width=0.7, label=:none, 
    color=sample_color, xticks=(1:1:6, xnames), yticks=(0:0.5:1, ynames),
    ytickfont=font(12), xtickfont=font(12), xrotation=20, grid=false, 
    right_margin = 30Plots.mm, linecolor=:match)

# create a separate plot for legend
xlength = length(continent)
scatter!(local_plt, ones(xlength), collect(1:xlength), color=continent_colors, ytick=(1:xlength, continent), 
    xrange=(0.9, 1.1), xtick=false, label=:none, markersize=6, ytickfont=font(12),
    grid=false, framestyle=:grid, mirror=true, tick_direction=:out, markershape=:rect,
    inset = (1, bbox(-0.05, -0.1, 0.05, 1.1, :bottom, :right)), subplot = 2)

# save figure
# savefig(local_plt, &quot;local_admixture.png&quot;)</code></pre><p><img src="../output_15_0.svg" alt="svg"/></p><p><strong>Conclusion:</strong> </p><ul><li>We can visualize the linkage patterns for the 3 samples across their 6 haplotypes</li><li>Sample 1 (British) is mostly European and admixed American, sample 2 (Chinese) is mainly South/East Asian, and sample 3 (Kenyan) is mainly African.</li></ul><p>For more details, please refer to our paper, or file an issue on GitHub. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../performance/">« Performance Gotchas</a><a class="docs-footer-nextpage" href="../ultra+compress/">Ultra compression »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Wednesday 11 May 2022 02:49">Wednesday 11 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
